[TOC]



## 概要：

Go语言最初由Google公司的Robert Griesemer、Ken Thompson和Rob Pike三个大牛于2007年开始设计发明，他们最终的目标是设计一种适应网络和多核时代的C语言。所以Go语言很多时候被描述为“类C语言”，或者是“21世纪的C语言”，当然从各种角度看，Go语言确实是从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等诸多编程思想。但是Go语言更是对C语言最彻底的一次扬弃，它**舍弃了C语言中灵活但是危险的指针运算**，还**重新设计了C语言中部分不太合理运算符的优先级**，并在很多细微的地方都做了必要的打磨和改变.

Go语言的**基本组成**有：

- 包声明，编写源文件时，必须在非注释的第一行指明这个文件属于哪个包，如package main。
- 引入包，其实就是告诉Go 编译器这个程序需要使用的包，如import "fmt"其实就是引入了fmt包。
- 函数，和c语言相同，即是一个可以实现某一个功能的函数体，每一个可执行程序中必须拥有一个main函数。
- 变量，Go 语言变量名由字母、数字、下划线组成，其中首个字符不能为数字。
- 语句/表达式，在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。
- 注释，和c语言中的注释方式相同，可以在任何地方使用以 // 开头的单行注释。以 /* 开头，并以 */ 结尾来进行多行注释，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。

## 1、数据类型、类型转换：

Go语言中的基本数据类型包括整型、浮点型、布尔型、字符串等。

类型转换使用 `type(value)` 的形式进行，例如 `int(x)` 表示将变量 `x` 转换为整型。 



## 2、变量、常量：

:=符号当我们定义一个变量后又使用该符号初始化变量，就会产生编译错误，因为该符号其实是一个声明语句。

使用格式：`typename := value`

也就是说`intVal := 1`相等于：

```go
var intVal int 
intVal =1 
12
```

 多变量声明
可以同时声明多个类型相同的变量（非全局变量），如下图所示：

```go
var c, d int = 1, 2
g, h := 123, "hello"

```

​         函数内定义的变量为**局部变量**，这种局部变量的作用域只在函数体内，函数的参数和返回值变量都属于局部变量。这种变量在存在于函数被调用时，销毁于函数调用结束后。
​         函数外定义的变量为**全局变量**，全局变量只需要在一个源文件中定义，就可以在所有源文件中使用，甚至可以使用import引入外部包来使用。全局变量声明必须以 var 关键字开头，如果想要在外部包中使用全局变量的首字母必须大写。
​         函数定义中的变量成为**形式参数**，定义函数时函数名后面括号中的变量叫做形式参数（简称形参）。形式参数只在函数调用时才会生效，函数调用结束后就会被销毁，在函数未被调用时，函数的形参并不占用实际的存储单元，也没有实际值。形式参数会作为函数的局部变量来使用。



## 3、运算符、表达式：

#### 算术运算符

- `+`：加法
- `-`：减法
- `*`：乘法
- `/`：除法
- `%`：取模（取余）

#### 比较运算符

- `==`：等于
- `!=`：不等于
- `<`：小于
- `<=`：小于等于
- `>`：大于
- `>=`：大于等于

#### 逻辑运算符

- `&&`：逻辑与（and）
- `||`：逻辑或（or）
- `!`：逻辑非（not）

#### 位运算符

- `&`：按位与（and）
- `|`：按位或（or）
- `^`：按位异或（xor）

#### 赋值运算符

- `=`：赋值
- `+=`：加后赋值
- `-=`：减后赋值
- `*=`：乘后赋值
- `/=`：除后赋值
- `%=`：取模后赋值

#### 其他运算符

- `&`：取地址
- `*`：解引用
- `<-`：用于通道的发送和接收操作

#### 算术表达式

```
gosum := a + b
difference := a - b
product := a * b
quotient := a / b
remainder := a % b
```

#### 逻辑表达式

```
goresult := (x > 5) && (y < 10)
```

#### 条件表达式

```
gomax := a
if b > a {
    max = b
}
```

#### 函数调用表达式

```
goresult := add(3, 5)
```

#### 类型转换表达式

```
gox := 10
y := float64(x)
```

#### 指针表达式

```
govar p *int
x := 10
p = &x // p 指向 x 的地址
```

#### 通道操作表达式

```
goch := make(chan int)
ch <- 42 // 发送数据到通道
data := <-ch // 从通道接收数据
```

#### 复合字面值表达式

```
govar m = map[string]int{"a": 1, "b": 2}
```



## 4、输入输出：

输入可以使用 `fmt.Scan()` 或 `fmt.Scanln()`。

输出使用 `fmt.Println()` 或 `fmt.Printf()`。   （此处类似于c语言）



## 5、分支逻辑：

### 分支逻辑

#### 1. if语句

`if` 语句用于基本的条件判断：

```
goif condition {
    // code to be executed if condition is true
} else {
    // code to be executed if condition is false
}
```

#### 2. switch语句

`switch` 语句用于多条件判断，可以更清晰地替代多个 `if-else` 语句：

```
goswitch variable {
case value1:
    // code to be executed if variable == value1
case value2:
    // code to be executed if variable == value2
default:
    // code to be executed if none of the cases match
}
```

#### 3. select语句

`select` 语句用于在多个通道操作中进行选择，用于处理并发程序：

```
goselect {
case msg1 := <-ch1:
    // code to handle msg1 from ch1
case msg2 := <-ch2:
    // code to handle msg2 from ch2
default:
    // code to be executed if no communication case is ready
}
```



## 6、循环逻辑

#### 1. for循环

`for` 循环是 Go 中主要的循环结构，支持多种形式：

- 基本形式：

  ```
  gofor i := 0; i < 5; i++ {
      // code to be executed in each iteration
  }
  ```

- 类似 while 的形式：

  ```
  gofor condition {
      // code to be executed as long as condition is true
  }
  ```

- 无限循环：

  ```
  gofor {
      // code to be executed indefinitely
  }
  ```

#### 2. range循环

`range` 关键字用于迭代数组、切片、字符串、映射等数据结构：

```
gonumbers := []int{1, 2, 3, 4, 5}
for index, value := range numbers {
    // code to be executed for each iteration
}
```

#### 3. break和continue

`break` 用于跳出循环，而 `continue` 用于跳过当前循环的剩余代码并进入下一次迭代。

```
gofor i := 0; i < 10; i++ {
    if i == 5 {
        break // 跳出循环
    }
    if i%2 == 0 {
        continue // 跳过本次循环的剩余代码，进入下一次迭代
    }
    // code to be executed for each iteration
}
```



## 7、数组：

数组是具有相同数据类型的元素的集合，长度固定。

声明数组使用 `var arrayName [length]dataType`。

```go
var balance [10] float32
```

数组的**初始化**方式有不止一种方式，我们列举如下：

**直接进行初始化**：

 var balance = [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

**通过字面量在声明数组的同时快速初始化数组**：

balance := [5]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

**数组长度不确定**，编译器通过元素个数自行推断数组长度，在[ ]中填入...，举例如下：

var balance = [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}  和

balance := [...]float32{1000.0, 2.0, 3.4, 7.0, 50.0}

**数组长度确定**，指定下标进行部分初始化：balanced := [5]float32(1:2.0, 3:7.0)

Tips：此处联想到c语言数组名，对此进行进一步了解。具体如下：

在 Go 语言中，数组名代表了数组的第一个元素的地址。这与 C 语言中的数组名类似。但是，与 C 语言不同的是，Go 语言中的数组是值类型，而不是引用类型。这意味着当你将一个数组传递给函数时，实际上传递的是数组的副本，而不是原始数组本身。

Go 语言中的数组是固定大小的序列，其中的每个元素都具有相同的类型。数组的声明语法如下：

```go
govar arrayName [size]dataType
```

其中，`arrayName` 是数组的名称，`size` 是数组的大小，`dataType` 是数组中元素的数据类型。

当你声明一个数组并为其分配内存时，`arrayName` 将代表数组的第一个元素的地址。可以通过索引访问数组中的元素，语法为 `arrayName[index]`，其中 `index` 是元素的索引，从 0 开始计数。

例如：

```go
govar numbers [5]int // 声明一个包含 5 个整数的数组
numbers[0] = 10    // 将第一个元素设置为 10
```

在 Go 中，数组的名称本质上是一个指向数组的指针。这意味着当你将数组传递给函数时，实际上传递的是数组的副本，并不会传递整个数组的内容。如果你希望函数能够修改数组的内容，并且这些修改在函数外部可见，你可以将指向数组的指针传递给函数。

需要注意的是，在 Go 中，切片（slice）通常更常用，因为切片是动态大小的序列，而且更加灵活。数组通常在需要固定大小的场景下使用。



## 8、切片：

简单地说，**切片就是一种简化版的动态数组**。这是我浏览过所有文章看到的最普遍的一句话。因为动态数组的长度不固定，切片的长度自然也就不能是类型的组成部分了。数组虽然有适用它们的地方，但是数组的类型和操作都不够灵活，而切片则使用得相当广泛。

切片高效操作的要点是要降低内存分配的次数。

```go
type SliceHeader struct {
    Data uintptr   // 指向底层的的数组指针
    Len  int	   // 切片长度
    Cap  int	   // 切片最大长度
}
```

和数组一样，内置的len函数返回切片中有效元素的长度，内置的cap函数返回切片容量大小，容量必须大于或等于切片的长度。

切片可以和nil进行比较，只有当**切片底层数据指针为空时**切片本身为nil，这时候**切片的长度和容量信息将是无效的**。如果有切片的底层数据指针为空，但是长度和容量不为0的情况，那么说明切片本身已经被损坏了

只要是**切片的底层**数据指针、长度和容量**没有发生变化**的话，对切片的遍历、元素的读取和修改都和数组是一样的。在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，只要是相同类型元素构成的切片均对应相同的切片类型。

当我们想定义声明一个切片时可以如下：

在对切片本身赋值或参数传递时，和数组指针的操作方式类似，只是复制切片头信息（reflect.SliceHeader），并不会复制底层的数据。对于类型，和数组的最大不同是，切片的类型和长度信息无关，**只要是相同类型元素构成的切片均对应相同的切片类型。**

接下来是我认为切片特殊所在的内容：

#####  添加元素

`append()` ：内置的泛型函数，可以向切片中增加元素。

1. 在切片尾部追加N个元素

   ```go
   var a []int
   a = append(a, 1)               // 追加1个元素
   a = append(a, 1, 2, 3)         // 追加多个元素, 手写解包方式
   a = append(a, []int{1,2,3}...) // 追加一个切片, 切片需要解包
   ```

   

2. 在切片开头位置添加元素

   ```go
   var a = []int{1,2,3}
   a = append([]int{0}, a...)        // 在开头位置添加1个元素
   a = append([]int{-3,-2,-1}, a...) // 在开头添加1个切片
   ```

   

3. append链式操作

   ```go
   var a []int
   a = append(a[:i], append([]int{x}, a[i:]...)...)     // 在第i个位置插入x
   a = append(a[:i], append([]int{1,2,3}, a[i:]...)...) // 在第i个位置插入切片
   
   ```

   

4. append和copy组合

   ```go
   a = append(a, 0)     // 切片扩展1个空间
   copy(a[i+1:], a[i:]) // a[i:]向后移动1个位置
   a[i] = x             // 设置新添加的元素
   ```

##### 删除元素

据要删除元素的位置有三种情况：

1、从开头位置删除；
直接移动数据指针，代码如下：

```go
a = []int{1, 2, 3, ...}
a = a[1:]                       // 删除开头1个元素
a = a[N:]                       // 删除开头N个元素
```

将后面的数据向开头移动，使用append原地完成（所谓原地完成是指在原有的切片数据对应的内存区间内完成，不会导致内存空间结构的变化）

```go
a = []int{1, 2, 3, ...}
a = append(a[:0], a[1:]...) // 删除开头1个元素
a = append(a[:0], a[N:]...) // 删除开头N个元素
```

使用copy将后续数据向前移动，代码如下：

```go
a = []int{1, 2, 3}
a = a[:copy(a, a[1:])] // 删除开头1个元素
a = a[:copy(a, a[N:])] // 删除开头N个元素
```


2、从中间位置删除；
对于删除中间的元素，需要对剩余的元素进行一次整体挪动，同样可以用append或copy原地完成：
append删除操作如下：

```go
a = []int{1, 2, 3, ...}
a = append(a[:i], a[i+1], ...)
a = append(a[:i], a[i+N:], ...)
```

copy删除操作如下：

```go
a = []int{1, 2, 3}
a = a[:copy(a[:i], a[i+1:])] // 删除中间1个元素
a = a[:copy(a[:i], a[i+N:])] // 删除中间N个元素
```



3、从尾部删除
代码如下所示：

```go
a = []int{1, 2, 3, ...}

a = a[:len(a)-1]   // 删除尾部1个元素
a = a[:len(a)-N]   // 删除尾部N个元素
```

删除切片尾部的元素是最快的



## 9、Map：

在 Go 语言中，`map` 是一种用来存储键值对的数据结构，类似于其他编程语言中的字典（dictionary）或关联数组（associative array）。`map` 是一种无序的集合，其中每个元素都是一对键值对，每个键（key）必须是唯一的，而值（value）可以是任意类型的数据。

#### 创建和初始化

要创建一个空的 `map`，可以使用 `make` 函数：

```
gomyMap := make(map[keyType]valueType)
```

或者使用字面量的方式初始化 `map`：

```
gomyMap := map[keyType]valueType{
    key1: value1,
    key2: value2,
    // ...
}
```

#### 插入和访问元素

向 `map` 中插入元素的方法类似于对数组和切片进行赋值：

```
gomyMap[key] = value
```

通过键来访问元素的值：

```
govalue := myMap[key]
```

#### 删除元素

使用 `delete` 函数从 `map` 中删除键值对：

```
godelete(myMap, key)
```

#### 判断键是否存在

使用多重赋值方式判断键是否存在：

```
govalue, ok := myMap[key]
if ok {
    // 键存在，value 变量中存储了键对应的值
} else {
    // 键不存在
}
```

#### 遍历 `map`

可以使用 `range` 关键字来遍历 `map` 中的键值对：

```
gofor key, value := range myMap {
    // code to be executed for each key-value pair
}
```

#### 注意事项

- `map` 是引用类型，在函数间传递时会传递引用而不是值的副本。
- 对未初始化的 `map` 进行读取操作会返回零值，但写入操作会导致运行时错误。
- `map` 的键可以是
- 可比较的类型，包括所有的内置类型除了切片、映射和函数类型。
- `map` 不是线程安全的，如果在多个 goroutine 中并发访问和修改同一个 `map`，需要通过加锁来确保安全性。



## 10、函数：

在Go语言中，函数是第一类对象，我们可以将函数保持到变量中。函数主要有**具名**和**匿名**之分，包级函数一般都是具名函数，具名函数是匿名函数的一种特例，当匿名函数引用了外部作用域中的变量时就成了**闭包函数**，闭包函数是函数式编程语言的核心。

- 具名函数：就和c语言中的普通函数意义相同，具有函数名、返回值以及函数参数的函数。
- 匿名函数：指不需要定义函数名的一种函数实现方式，它由一个不带函数名的函数声明和函数体组成。

函数使用 `func` 关键字声明。具体格式参照如下：

```go
func fuction_name([parameter list])[return types]{
	函数体
}
```

支持多返回值，匿名函数，函数作为参数和函数作为返回值等特性。

ps：defer语句延迟执行的其实是一个匿名函数，因为这个匿名函数捕获了外部函数的局部变量v，这种函数我们一般叫闭包。闭包对捕获的外部变量并不是传值方式访问，而是以**引用**的方式访问。



## 11、指针：

在 Go 语言中，指针（pointer）是一种特殊类型的变量，用于存储另一个变量的内存地址。与其他一些编程语言不同，Go 语言中的指针并不支持进行指针运算，而是提供了简洁而安全的方式来处理指针。

#### 定义指针

在 Go 语言中，可以使用 `*` 符号来声明一个指针变量，例如：

```
govar ptr *int  // 声明一个指向整数的指针
```

在这个例子中，`ptr` 是一个指向整数的指针。

#### 获取变量的地址

可以使用 `&` 符号来获取一个变量的内存地址，例如：

```
govar num int = 42
ptr := &num  // ptr 指向 num 的内存地址
```

#### 获取指针所指向的值

可以使用 `*` 符号来获取指针所指向的值，例如：

```
govar num int = 42
ptr := &num
fmt.Println(*ptr)  // 输出 42
```

#### 修改指针所指向的值

可以通过指针来修改其所指向的值，例如：

```
govar num int = 42
ptr := &num
*ptr = 100  // 修改 ptr 所指向的值为 100
fmt.Println(num)  // 输出 100
```

#### 空指针

在 Go 语言中，空指针表示指针变量未指向任何有效的内存地址。可以使用 `nil` 关键字来表示空指针，例如：

```
govar ptr *int = nil
```

#### 判断指针是否为空

可以使用 `==` 操作符来判断指针是否为空，例如：

```
govar ptr *int = nil
if ptr == nil {
    fmt.Println("ptr is nil")
}
```

#### 传递指针给函数

可以将指针作为参数传递给函数，从而在函数内部修改原始变量的值，例如：

```
gofunc modifyValue(ptr *int) {
    *ptr = 100
}

var num int = 42
modifyValue(&num)
fmt.Println(num)  // 输出 100
```

#### 指针的安全性

Go 语言的指针是类型安全的，即只能指向特定类型的变量，不能进行指针运算，这样可以减少一些常见的错误。



## 12、包管理：

Go语言中通过 `import` 关键字引入包。

使用 `go mod` 进行包管理。



## 13、结构体：

在声明结构体之前我们首先需要定义一个结构体类型，这需要使用type和struct，type用于设定结构体的名称，struct用于定义一个新的数据类型。具体结构如下：

```
type struct_variable_type struct {
   member definition
   member definition
   ...
   member definition
}
```

定义好了结构体类型，我们就可以使用该结构体声明这样一个结构体变量，语法如下：

```
variable_name := structure_variable_type {value1, value2...valuen}

variable_name := structure_variable_type { key1: value1, key2: value2..., keyn: valuen}

```

如果要访问结构体成员，需要使用点号 `.` 操作符，格式为：`结构体变量名.成员名`。



## 14、方法和接口：

在 Go 语言中，接口（interfaces）是一种抽象类型，它定义了一组方法的集合。接口提供了一种方式，可以使不同的类型实现相同的方法集合，从而实现多态性和代码的灵活性。

#### 方法

在 Go 语言中，方法是与特定类型关联的函数。方法是通过将函数与一个接收者（receiver）关联而实现的。接收者可以是任何类型的值或指针。方法的声明语法如下：

```
gofunc (receiverType) methodName(parameters) returnTypes {
    // 方法的实现
}
```

其中，`receiverType` 是方法关联的类型，`methodName` 是方法的名称，`parameters` 是方法的参数列表，`returnTypes` 是方法的返回值列表。

#### 接口

接口是一种抽象类型，它定义了一组方法的集合。任何类型只要实现了接口中定义的所有方法，就被称为实现了该接口。接口的声明语法如下：

```
gotype InterfaceName interface {
    Method1(parameters) returnType
    Method2(parameters) returnType
    // 更多方法...
}
```

其中，`InterfaceName` 是接口的名称，`Method1`、`Method2` 等是接口定义的方法。

#### 接口的实现

要实现一个接口，只需实现接口中定义的所有方法即可，无需显式声明实现了某个接口。如果一个类型实现了接口中定义的所有方法，那么该类型就被视为实现了该接口。

```
gotype Shape interface {
    Area() float64
}

type Circle struct {
    radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.radius * c.radius
}
```

在上面的示例中，`Circle` 类型实现了 `Shape` 接口，因为它定义了 `Area()` 方法。

#### 空接口

空接口是没有任何方法的接口，因此任何类型都满足空接口。空接口在需要存储任意类型的值时非常有用。

```
govar any interface{}
any = 5         // 可以存储整数
any = "hello"   // 也可以存储字符串
```

#### 类型断言

类型断言用于检查接口值所包含的具体类型，并访问其对应的值。

```
govar i interface{} = "hello"

s := i.(string)
fmt.Println(s) // 输出: hello

s, ok := i.(string)
fmt.Println(s, ok) // 输出: hello true

f, ok := i.(float64)
fmt.Println(f, ok) // 输出: 0 false（0 是 float64 的零值）
```

#### 接口的嵌套和类型组合

接口可以嵌套在其他接口中，并通过类型组合的方式形成新的接口。这种方式可以用来将多个接口组合成一个更大的接口。

```
gotype Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p []byte) (n int, err error)
}

type ReadWriter interface {
    Reader
    Writer
}
```

#### 空接口的应用

空接口可以用来处理未知类型的数据，例如：

```
gofunc printValue(val interface{}) {
    fmt.Println(val)
}
```

这样的函数可以接受任何类型的参数，因为空接口可以接受任何类型的值。

这些是 Go 语言中方法和接口的基础知识。掌握了这些概念，你就能更好地理解和利用 Go 语言中的面向对象特性。


## 15、错误处理：

在 Go 语言中，错误处理是通过返回错误值（error）来完成的，而不是使用异常。这种错误处理模型鼓励显式地处理错误，使代码更加健壮和可靠。

#### 错误类型 

在 Go 中，错误被表示为一个内建的接口类型 `error`。`error` 接口类型只有一个方法：

```
gotype error interface {
    Error() string
}
```

`error` 接口包含一个 `Error()` 方法，该方法返回一个描述错误的字符串。

#### 函数返回错误

在 Go 中，函数通常会返回两个值：一个是函数的结果，另一个是可能的错误。例如：

```
gofunc doSomething() (int, error) {
    // 如果发生错误，则返回错误
    if somethingWrong {
        return 0, errors.New("something went wrong")
    }
    // 如果没有错误，则返回结果和 nil
    return result, nil
}
```

#### 错误检查

在调用返回错误的函数后，通常需要检查错误是否发生。这可以通过将返回的错误值与 `nil` 进行比较来完成。

```
goresult, err := doSomething()
if err != nil {
    // 处理错误
    fmt.Println("Error:", err)
} else {
    // 处理结果
    fmt.Println("Result:", result)
}
```

#### 错误处理最佳实践

- **错误不是异常**：在 Go 中，错误被认为是正常的程序流程，而不是异常。因此，不应该滥用错误处理来控制程序流程。
- **透明传递**：在函数中遇到错误时，最好不要在函数内部处理，而是将错误传递给调用方，让调用方决定如何处理错误。
- **错误信息包装**：在一些情况下，需要将更多的上下文信息附加到错误消息中，以便更好地了解发生了什么问题。可以使用 `errors.New()`、`fmt.Errorf()` 或者 `errors.Wrap()` 等函数来包装错误信息。

#### 错误处理库

Go 的标准库 `errors` 和 `fmt` 提供了一些用于处理错误的函数，例如：

- `errors.New()`：创建一个新的错误。
- `fmt.Errorf()`：创建一个带有格式化字符串的错误。
- `errors.Wrap()`：在现有错误的基础上添加上下文信息。

#### Panic 和 Recover

除了错误处理外，Go 还提供了 `panic` 和 `recover` 机制用于处理程序的非常严重错误。但是，`panic` 和 `recover` 应该被谨慎使用，并且仅在极端情况下才使用。



## 16、关键字：

Go 语言中的关键字是被编程语言保留的标识符，它们具有特殊的含义，不能用作自定义标识符（变量名、函数名等）。以下是 Go 语言的关键字列表：

1. **break**: 终止当前循环或 switch 语句，并跳出循环或 switch。
2. **default**: 在 switch 语句中用于指定没有匹配任何 case 时要执行的代码块。
3. **func**: 用于声明函数。
4. **interface**: 定义接口类型。
5. **select**: 用于在多个通信操作中选择一个执行。
6. **case**: 在 switch 语句中用于定义不同的匹配情况。
7. **defer**: 用于在函数退出时执行一些清理操作，常用于资源释放。
8. **go**: 用于启动一个新的 goroutine，实现并发编程。
9. **map**: 用于声明并创建 map 类型。
10. **struct**: 用于声明结构体类型。
11. **chan**: 用于声明并创建通道类型，用于在 goroutine 之间进行通信。
12. **else**: 在 if 语句中用于指定在条件不成立时要执行的代码块。
13. **goto**: 用于无条件跳转到指定的标签。
14. **package**: 用于声明 Go 程序的包（模块）。
15. **switch**: 用于根据不同的条件执行不同的代码块。
16. **const**: 用于声明常量。
17. **if**: 用于条件判断，根据条件执行不同的代码块。
18. **range**: 用于迭代数组、切片、通道或映射的元素。
19. **type**: 用于声明自定义类型。
20. **continue**: 结束当前循环的迭代，并开始下一次迭代。
21. **import**: 用于导入包。
22. **return**: 用于从函数中返回值。
23. **var**: 用于声明变量。





个人学习结果：对map、指针、切片的理解不够深刻，尚未能够运用这三者，后续继续加强学习

​                           切片的学习过程更像是对数组的进一步运用，能方便增加减少数组长度

除此之外，我认为本篇笔记相比于完全记下来可能要消耗一定的时间，但在多次浏览之后脑海中留有印象并逐渐根据实际操作代码完善笔记，形成一个完善的适合自己的笔记才是重要的。

