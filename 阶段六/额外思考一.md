Go语言通过返回值来处理错误，而不是通过异常。

通常，Go的函数会返回两个值，一个是函数的正常返回值，另一个是错误。在调用函数后，需要检查错误值，如果为nil，则表示函数执行成功；否则，表示发生了错误。
以下是一个简单的示例：
func divide(a, b int) (int, error) {
    if b == 0 {
        return 0, errors.New("division by zero")
    }
    return a / b, nil
}

func main() {
    result, err := divide(10, 2)
    if err != nil {
        fmt.Println("Error:", err)
    } else {
        fmt.Println("Result:", result)
    }
}

在这个例子中，divide 函数返回两个值，商和错误。在 main 函数中，我们检查错误值并相应地处理。
至于网上嘲讽Go错误处理的方式，一些人批评它显得有些繁琐，因为需要在每个函数调用后检查错误。相比于其他语言的异常机制，这被认为增加了代码的冗余性。然而，Go的设计哲学是显式地处理错误，以避免隐藏错误并强制程序员更仔细地处理边界情况。
关于C语言，它没有内置的异常机制，而是依赖于错误码的传递。C函数通常通过返回整数或指针来表示成功或失败，程序员需要检查这些返回值并相应地处理错误。
例如：
#include &lt;stdio.h&gt;

int divide(int a, int b, int* result) {
    if (b == 0) {
        return -1; // 表示错误
    }
    *result = a / b;
    return 0; // 表示成功
}

int main() {
    int result;
    if (divide(10, 2, &amp;result) == 0) {
        printf("Result: %d\n", result);
    } else {
        printf("Error: division by zero\n");
    }
    return 0;
}

在这个例子中，divide 函数返回一个错误码，如果调用者收到非零的错误码，就知道发生了错误。这种方式也是显式的错误处理，类似于Go的做法。



参考自 csdn    chatgpt





