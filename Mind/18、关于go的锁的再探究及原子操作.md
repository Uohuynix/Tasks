### **为什么要有锁？**

为什么并发中要有锁的概念？此片笔记只针对简单概念进行了解。

并发是开启了多个线程去做某一件事情，比如多个线程如果同时去访问某一个资源的话，那么这个资源就被称为临界区（对于这种临界区资源进行操作，需要保证操作的原子性，是一次仅允许一个进程使用。）
CPU操作一个命令的时候，会这样执行：
①控制器从**程序计时器**读取执行指令的地址

②控制器**根据地址**加载指令

③控制器将指令交给**运算器**

④**运算器**根据指令进行计算

在Go语言中，**锁是用于保证并发安全的重要工具**。当多个goroutine（Go语言的轻量级线程）同时访问共享数据时，如果不加以控制，就可能导致数据竞争和不一致。锁的作用就是提供一种同步机制，**确保同一时间只有一个goroutine可以访问共享数据。**

Go语言中常见的锁包括互斥锁和读写锁。

**互斥锁**

互斥锁是最常用的锁之一，它保证了对共享资源的互斥访问。当一个goroutine获得了互斥锁并正在访问共享资源时，其他goroutine必须等待，直到锁被释放。在Go语言中，互斥锁由`sync.Mutex`结构体表示，提供了`Lock()`和`Unlock()`两个方法，用于加锁和解锁。加锁后，其他试图加锁的goroutine将被阻塞，直到锁被解锁。使用互斥锁时，需要注意避免出现死锁，即两个或更多goroutine互相等待对方释放资源的情况。

**读写锁**

读写锁是一种特殊的互斥锁，它针对读写操作进行了优化。读写锁允许多个goroutine同时读取共享资源，但在写入时仍然保证互斥访问。这意味着，在多个goroutine只需要读取数据而不需要修改数据时，它们可以同时进行读取操作，提高了并发性能。然而，当需要写入数据时，仍然需要获取写锁，此时其他读写操作都将被阻塞。Go语言中的读写锁由`sync.RWMutex`结构体表示，提供了`RLock()`、`RUnlock()`、`Lock()`和`Unlock()`等方法，分别用于加读锁、解读锁、加写锁和解写锁。

除了互斥锁和读写锁外，Go语言还提供了原子操作来实现**无锁并发**。原子操作是一种**不可中断**的操作，即在执行完毕之前不会被其他goroutine打断。Go语言的`sync/atomic`包提供了一组原子函数，用于执行整数、指针和布尔值的原子操作。原子操作通常用于实现简单的并发计数器、标志位等场景。

**以下内容对上文所提到的原子操作进行进一步了解(包括大致特点及注意事项)：**

原子操作是一种在多线程或多核环境中，确保某个操作不会被线程调度机制打断或中断的机制。简单来说，原子操作是一个不可分割的操作，一旦开始执行，就必须完全执行完毕，中间不会被其他线程或CPU核打断。

原子操作的主要特点包括：

1. **不可分割性**：原子操作在执行过程中不会被其他任务或事件中断，保证了操作的完整性。
2. **顺序性**：原子操作内的多个步骤顺序不会被打乱或切割，确保操作的逻辑正确性。
3. **无锁性**：原子操作通常不需要使用锁，因此具有较低的性能开销。

在运用原子操作时，需要注意以下几点：

1. **适用场景**：原子操作适用于简单的数据更新操作，如计数器增减、状态标志更新等。对于复杂的逻辑或数据结构操作，可能需要考虑使用锁或其他同步机制。
2. **数据类型限制**：原子操作通常适用于简单的数据类型，如整数、指针和布尔值。对于复杂的数据结构或对象，原子操作可能无法满足需求。
3. **复合操作的考虑**：原子操作只能保证单个操作的原子性，对于涉及多个步骤的复合操作，需要谨慎处理。可能需要使用额外的同步机制来确保复合操作的原子性。
4. **平台与语言差异**：不同的编程语言和平台对原子操作的支持和实现可能存在差异。因此，在使用原子操作时，需要了解并遵循特定平台和语言的规范和要求。。